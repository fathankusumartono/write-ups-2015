use std::io::prelude::*;
use std::net::TcpStream;

#[derive(Debug)]
enum Call {
  Lock(Vec<u8>),
  Get(Vec<u8>),
  Write(Vec<u8>),
  List,
} impl Call {
  fn encode(&self) -> [u8; 128] {
    let mut res = [0; 128];
    match *self {
      Call::Lock(ref s) => {
        res[0] = 0;
        for i in 0..s.len() {
          res[i+1] = s[i];
        }            
      }
      Call::Get(ref s) => {
        res[0] = 1;
        for i in 0..s.len() {
          res[i+1] = s[i];
        }            
      }
      Call::Write(ref s) => {
        res[0] = 2;
        for i in 0..s.len() {
          res[i+1] = s[i];
        }            
      }
      Call::List => res[0] = 3,
    }

    res
  }

  fn decode(s: &Vec<u8>) -> Call {
    let mut s = s.clone();
    let t = s.remove(0);
    match t {
      0 => Call::Lock(s),
      1 => Call::Get(s),
      2 => Call::Write(s),
      3 => Call::List,
      _ => panic!(),
    }
  }
}

#[derive(Debug)]
enum Resp {
  Fail,
  LockAcquired,
  File(Vec<u8>),
  PP(Vec<u8>),
} impl Resp {
  fn encode(&self) -> [u8; 128] {
    let mut res = [0; 128];
    match *self {
      Resp::Fail => {}
      Resp::LockAcquired => res[0] = 1,
      Resp::File(ref s) => {
        res[0] = 2;
        for i in 0..s.len() {
          res[i+1] = s[i];
        }
      }
      Resp::PP(ref s) => {
        res[0] = 3;
        for i in 0..s.len() {
          res[i+1] = s[i];
        }
      }
    }
    res
  }
  
  fn decode(s: &Vec<u8>) -> Resp {
    let mut s = s.clone();
    let t = s.remove(0);
    match t {
      0 => Resp::Fail,
      1 => Resp::LockAcquired,
      2 => Resp::File(s),
      3 => Resp::PP(s),
      _ => panic!(),
    }
  }  
}


fn main() {
  let mut stream = TcpStream::connect("127.0.0.1:9999").unwrap();

  let mut buf = vec![0; 128];
  
  let _ = stream.write(&Call::Write(Vec::from("k")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Write(Vec::from("e")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Write(Vec::from("y")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Write(Vec::from("s")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Write(Vec::from(":")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Write(Vec::from(")")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Lock(Vec::from("k")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Lock(Vec::from("e")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Lock(Vec::from("y")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Lock(Vec::from("s")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Lock(Vec::from(":")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Lock(Vec::from(")")).encode());
  let _ = stream.read(&mut buf);
  println!("{:?}", Resp::decode(&buf));

  let _ = stream.write(&Call::Get(Vec::from("key")).encode());
  let _ = stream.read(&mut buf);
  match Resp::decode(&buf) {
    Resp::File(v) => {
      println!("{:?}", String::from_utf8(v).unwrap());
    }
    _ => panic!("Didn't get flage D:"),
  }
}
